**问题**：对于一个十进制正整数N，计算1~N中所有的数，出现“1”的次数。例如f(11)=4。
**问题来源**：《编程之美》2.4节 P132~P138

**解法**：

1. `countNum1.r`使用遍历的方式，对1~N中每个数字，计算其含有“1”的个数，加起来得到问题的结果；
2. `countNum2.r`从数字本身出发，首先得到了一个数字（例如abc）中每一位（个十百位）上出现1的数目，最后求和。

**简介**：
对于第二种方法，其运算效率要远高于第一种方法。以三位数为例，给出第二种方法的简介：

数字为abc，依次计算：

##### 1. 个位上出现“1”的次数
决定权在比他高的位上，即百位与十位：

1. 若c=0，则有ab个
2. 若c=1，则有ab+1个
3. 若c>1，则有ab+1个

##### 2. 十位上出现“1”的次数
决定权在两边的数，即百位与个位：

1. 若b=0，则有a*10个
2. 若b=1，则有a*10+c+1个
3. 若b>1，则有(a+1)*10个

##### 3. 百位上出现“1”的次数
决定权在其后面的数：

1. 若a=0, 则有0个
2. 若a=1，则有bc个
3. 若a>1，则有100个

#### 这样我们就可以发现规律：
对于任意数字N，其中某一位上的数x，不妨假设其左侧的数为a，右侧数为b（若没有，就假设为0），则有：

1. 若x=0，则有a*10个
2. 若x=1，则有a*10+c+1个
3. 若x>1，则有(a+1)*10个

如此就可以得到`countNum2.r`的算法结构。